# Chapter 5 main()은 누가 호출하나
main()은 누가 호출하나?

main()도 하나의 함수인데, 누군가 호출해야 작동하지않을까? 시스템(윈도우, 리눅스)이 할까? 
그렇다면 임베디드 시스템(운영체제가 없을 때)에서는 어떻게 main()이 시작될까?

C 프로그램에서 사용하는 스택이나 힙, 정적 메모리는 누가 만드는가?

**스타트업(start up) 코드**
C 프로그램이 작동되기 위해서 준비 과정이 필요

crt0.s 라는 어셈블리 파일: 여러 초기화 작업과 C가 사용할 메모리를 할당 해주는 준비 과정을 수행 후 main 함수 호출

# 운영체제가 있는 경우의 main() 호출 과정
C 소스 컴파일한 실행 파일 -> HDD에 저장

실행 파일 헤더 -> 실행 파일 종류 파악 -> 사용할 핸들러 결정

핸들러는 각 섹션 정보 해석 -> 데이터 RAM에 로드

## RAM에 로드되는 순서 및 용어 정리
**섹션** : 오브젝트 파일은 코드나 데이터의 종류별로 영역을 나누어 관리

**세그먼트** : 오브젝트 파일이 섹션에 로드 된 메모리 영역

data 세그먼트 -> bss 세그먼트 (초기화 되지 않는 전역 데이터) -> 힙 -> 스택 

## 리눅스에서의 프로그램 실행 과정
리눅스 운영체제에서는 프로세스를 복사하는 것이 실행의 시작이다.

리눅스의 모든 프로세스는 부모와 자식의 관계로 이루어져 있다.

프로그램 수행 명령 -> fork -> execve() -> sys_execve() -> do_execve() -> 포멧에 맞는 handler로 실행.....

execve : 시스템 콜 함수, 사용자 모드에서 커널모드로 전환 

## 운영체제가 없는 경우의 main() 호출과정
**부트 코드** : 하드웨어 초기화 

**스타트업 코드** : C 프로그램이 작동될 수 있는 환경을 만듬

### crt0.s 스타트업 코드 진행 과정
1. 인터럽트 사용불가 설정
2. rw_data를 ROM에서 RAM으로 복사
3. ZI(bss)영역을 0으로 클리어
4. 모드별 stack 생성
5. 힙 생성
6. 인터럽트 사용가능 설정
7. main 호출

### 실제 스타트업 코드 
ARM 마이크로프로세서의 부트 코드

1. 엔트리 포인트 지정과 예외 처리 벡터(Exception Vector) 설정
2. 초기화를 방해하는 장치 끄기
3. 시스템 클록 설정
4. 메모리 초기화
5. 모드 별 스택 생성
6. ROM의 data 세그먼트를 RAM에 복사
7. bss 섹션을 0으로 클리어
8. main으로 분기 
